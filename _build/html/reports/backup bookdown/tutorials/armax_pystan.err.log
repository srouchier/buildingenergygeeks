Traceback (most recent call last):
  File "/home/simon/anaconda3/envs/bayes_env/lib/python3.11/site-packages/jupyter_core/utils/__init__.py", line 154, in wrapped
    asyncio.get_running_loop()
RuntimeError: no running event loop

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/home/simon/anaconda3/envs/bayes_env/lib/python3.11/site-packages/jupyter_cache/executors/utils.py", line 58, in single_nb_execution
    executenb(
  File "/home/simon/anaconda3/envs/bayes_env/lib/python3.11/site-packages/nbclient/client.py", line 1319, in execute
    return NotebookClient(nb=nb, resources=resources, km=km, **kwargs).execute()
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/simon/anaconda3/envs/bayes_env/lib/python3.11/site-packages/jupyter_core/utils/__init__.py", line 158, in wrapped
    return loop.run_until_complete(inner)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/simon/anaconda3/envs/bayes_env/lib/python3.11/asyncio/base_events.py", line 654, in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
  File "/home/simon/anaconda3/envs/bayes_env/lib/python3.11/site-packages/nbclient/client.py", line 709, in async_execute
    await self.async_execute_cell(
  File "/home/simon/anaconda3/envs/bayes_env/lib/python3.11/site-packages/nbclient/client.py", line 1062, in async_execute_cell
    await self._check_raise_for_error(cell, cell_index, exec_reply)
  File "/home/simon/anaconda3/envs/bayes_env/lib/python3.11/site-packages/nbclient/client.py", line 918, in _check_raise_for_error
    raise CellExecutionError.from_cell_and_msg(cell, exec_reply_content)
nbclient.exceptions.CellExecutionError: An error occurred while executing the following cell:
------------------
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

# Stan
import stan

# %% Reading the data file
df = pd.read_csv('data/building_1298.csv')
df.set_index(pd.to_datetime(df['datetime']), inplace=True)
df.fillna(method='ffill', inplace=True)

# Adding the day of the week as a new feature in the dataset
df['hour'] = df.index.hour
df['dayofweek'] = df.index.dayofweek
df['weekend'] = ((df.index.weekday == 5) | (df.index.weekday == 6))

# %% First order ARMAX model
model_code = """
data {
  int<lower=0> T_train;     // data points (training)
  int<lower=0> K;       // number of predictors

  matrix[T_train, K] x;       // predictor matrix (training and test)
  vector[T_train] y;    // output data
}

parameters {
  real mu;           // mean coeff
  real phi;          // AR
  real theta;        // MA
  real theta_x[K];   // X
  real<lower=0> sigma;
}

model {
  vector[T_train] nu;             // prediction for time t
  vector[T_train] err;            // error for time t
  
  // priors
  // phi ~ uniform(0, 1);

  // initialisation
  nu[1] = y[1];
  err[1] = 0;

  // the rest of the time steps
  for (t in 2:T_train) {
    real ex = 0;
    for (j in 1:K)
      ex += theta_x[j] * x[t, j];
    nu[t] = mu + phi * y[t-1] + theta * err[t-1] + ex;
    err[t] = y[t] - nu[t];
    }

   err ~ normal(0, sigma);  // likelihood is here
}
"""



# %% Setting up the modelling boundaries

# Choosing the period for training and test data
training_start = '2016-03-01 00:00:00'
training_end = '2016-03-31 23:00:00'
test_end = '2016-04-07 23:00:00'
df = df.drop(df.index[(df.index < pd.to_datetime(training_start)) | (df.index > pd.to_datetime(test_end))])
training_mask = df.index <= pd.to_datetime(training_end)

# Choosing the input and output features of the model
# x = df[['tite', 'i_sol', 'tits']]
x = df[['air_temperature']]
y = df['m0']
x_train = x.iloc[training_mask]
y_train = y.iloc[training_mask]

arx_data = {'T_train': len(y_train),
            'K': np.shape(x_train)[1],
            'x': x_train.values,
            'y': y_train.values}

#%% Learning

init0 = [{"mu":300}, {"phi":0.6}, {"theta":-0.4}, {"sigma":50}]     # for meter 0
init1 = [{"mu":800}, {"phi":0.8}, {"sigma":500}]                    # for meter 1
control = {'adapt_delta': 0.9, 'max_treedepth': 15}

posterior = stan.build(model_code, data=arx_data)
fit = posterior.sample(num_chains=4, num_samples=1000, init=init0)
df_post = fit.to_frame()

# %% Calculating the information criteria
P = 1
Q = 1
K = 1
T = len(y_train)

logL = df_post['lp__'].max()
AIC = -2 * logL + 2 * (P + Q + K + 1)
AICc = AIC + 2 * (P + Q + K + 1) * (P + Q + K + 2) / (T - P - Q - K - 2)

# %% Predictions

def prediction(sample):
    mu = df_post['mu'][sample]
    phi = df_post['phi'][sample]
    theta = df_post['theta'][sample]
    theta_x = df_post.loc[sample, df_post.columns.str.contains('theta_x')]
    sigma = df_post['sigma'][sample]

    y_new = np.zeros(len(y))
    err_new = np.zeros(len(y))

    # initialisation
    y_new[0] = y_train[0]
    err_new[0] = 0

    for t in range(P, len(y_train)):
        ex = 0
        for j in range(0, np.shape(x)[1]):
            ex += theta_x[j] * x.iloc[t, j]
        y_new[t] = mu + phi * y_train.iloc[t-1] + theta * err_new[t-1] + ex
        err_new[t] = y_train.iloc[t] - y_new[t]
    # all time steps that do not have observations
    for t in range(len(y_train), len(y)):
        ex = 0
        for j in range(0, np.shape(x)[1]):
            ex += theta_x[j] * x.iloc[t, j]
        y_new[t] = mu + phi * y_new[t-1] + theta * err_new[t-1] + ex
        err_new[t] = 0

    return y_new, err_new


# %% Plotting the predictions over the test period

t_ = df.index
teal = '#029386'
orange = '#F97306'

fig, ax = plt.subplots(figsize=(8, 4))
ax.plot(t_, y, color=teal, label='Observation')

essais = 50
y_new = np.zeros((essais, len(df)))
err_new = np.zeros((essais, len(df)))
for i in range(essais):
    sample = np.random.randint(0, len(df_post['mu']))
    y_new[i], err_new[i] = prediction(sample)
    ax.plot(t_, y_new[i], color=orange, alpha=0.2)
# ax.fill_between(t_, y_pred_avg-2*y_pred_std, y_pred_avg+2*y_pred_std, color=orange, alpha=0.3)
ax.set_ylabel('Heat pump energy use (Wh/15min)')
ax.legend()
# ax.set_xlim([pd.to_datetime(training_end), pd.to_datetime(test_end)])
plt.show()

------------------


[31m---------------------------------------------------------------------------[39m
[31mRuntimeError[39m                              Traceback (most recent call last)
[36mCell[39m[36m [39m[32mIn[1][39m[32m, line 89[39m
[32m     86[39m init1 = [{[33m"[39m[33mmu[39m[33m"[39m:[32m800[39m}, {[33m"[39m[33mphi[39m[33m"[39m:[32m0.8[39m}, {[33m"[39m[33msigma[39m[33m"[39m:[32m500[39m}]                    [38;5;66;03m# for meter 1[39;00m
[32m     87[39m control = {[33m'[39m[33madapt_delta[39m[33m'[39m: [32m0.9[39m, [33m'[39m[33mmax_treedepth[39m[33m'[39m: [32m15[39m}
[32m---> [39m[32m89[39m posterior = [43mstan[49m[43m.[49m[43mbuild[49m[43m([49m[43mmodel_code[49m[43m,[49m[43m [49m[43mdata[49m[43m=[49m[43marx_data[49m[43m)[49m
[32m     90[39m fit = posterior.sample(num_chains=[32m4[39m, num_samples=[32m1000[39m, init=init0)
[32m     91[39m df_post = fit.to_frame()

[36mFile [39m[32m~/anaconda3/envs/bayes_env/lib/python3.11/site-packages/stan/model.py:519[39m, in [36mbuild[39m[34m(program_code, data, random_seed)[39m
[32m    516[39m         [38;5;28;01mreturn[39;00m Model(model_name, program_code, data, param_names, constrained_param_names, dims, random_seed)
[32m    518[39m [38;5;28;01mtry[39;00m:
[32m--> [39m[32m519[39m     [38;5;28;01mreturn[39;00m [43masyncio[49m[43m.[49m[43mrun[49m[43m([49m[43mgo[49m[43m([49m[43m)[49m[43m)[49m
[32m    520[39m [38;5;28;01mexcept[39;00m [38;5;167;01mKeyboardInterrupt[39;00m:
[32m    521[39m     [38;5;28;01mreturn[39;00m

[36mFile [39m[32m~/anaconda3/envs/bayes_env/lib/python3.11/asyncio/runners.py:186[39m, in [36mrun[39m[34m(main, debug)[39m
[32m    161[39m [38;5;250m[39m[33;03m"""Execute the coroutine and return the result.[39;00m
[32m    162[39m 
[32m    163[39m [33;03mThis function runs the passed coroutine, taking care of[39;00m
[32m   (...)[39m[32m    182[39m [33;03m    asyncio.run(main())[39;00m
[32m    183[39m [33;03m"""[39;00m
[32m    184[39m [38;5;28;01mif[39;00m events._get_running_loop() [38;5;129;01mis[39;00m [38;5;129;01mnot[39;00m [38;5;28;01mNone[39;00m:
[32m    185[39m     [38;5;66;03m# fail fast with short traceback[39;00m
[32m--> [39m[32m186[39m     [38;5;28;01mraise[39;00m [38;5;167;01mRuntimeError[39;00m(
[32m    187[39m         [33m"[39m[33masyncio.run() cannot be called from a running event loop[39m[33m"[39m)
[32m    189[39m [38;5;28;01mwith[39;00m Runner(debug=debug) [38;5;28;01mas[39;00m runner:
[32m    190[39m     [38;5;28;01mreturn[39;00m runner.run(main)

[31mRuntimeError[39m: asyncio.run() cannot be called from a running event loop

